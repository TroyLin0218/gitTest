### MySQL

#### 1.架构:

MySQL架构大致可以分为Server层和引擎层:

* Server层包括了连接器,查询缓存,分析器,优化器,执行器等;Server层包含了大部分的核心功能,以及内置的函数(日期,时间,数字,加密函数);
* 引擎层主要包含了存储过程,触发器,试图等

一条查询SQL: 

```sql
select * from t where t.id = '1';
```

##### 连接器:

查询时,连接器负责和客户端建立链接,获取权限,维持和管理链接.

`数据库`中长连接是指链接成功之后,如果客户端持续有请求,则一直使用同一个链接.

`短链接`是指每次执行完很少的几次查询就断开链接,下次查询时重新建立一个链接.

建立链接时复杂且耗费资源的,建议使用长连接.但是全部使用长连接之后,会导致MySQL内存占用涨的很快,这是因为MySQL再执行过程中临时使用的内存是管理在链接对象里面的.这些资源只有在链接断开之后才会释放,长期累积之后,会导致内存占用过大,被系统强行杀掉,看起来就像MySQL重启了.

*解决方案*:	

​	MySQL5.7之后可以在每次执行完一次长连接之后使用`mysql_reset_connection`来重新初始化链接资源.这个过程不需要重连和权限校验,会恢复到链接刚刚建立时的状态.

##### 查询缓存

建立完链接之后,就可以开始执行select语句了.第二步是`查询缓存`.

MySQL拿到一个查询语句之后会先去查询缓存看看之前是不是查询过,查询缓存是K-V形式存储形式,key是查询SQL,value是查询结果,.命中之后直接返回结果.

但实际上,MySQL缓存失效很频繁,只要对表进行更新过,这个表所有的缓存便被清空了.

查询缓存只适用在静态表,或者长时间不更新的表.

MySQL实际上实现了按需使用,可以设置`query_cache_type`为`DEMAND` ,这时候默认查询都不走缓存.对于需要走缓存的可以显式指定SQL_CACHE:

```sql
select SQL_CACHE  * from T where T.id = '1';
```

**MySQL8.0之后查询缓存被整块的删除了.**

##### 分析器

没有命中查询缓存之后就真正的开始查询了,分析器主要做两件事:

首先是`词法分析`:将客户端传来的sql语句识别出来关键字,识别出来那个字符串是表名,哪个字符串是列名等.

其次是`语法分析`:做完识别之后就需要做语法分析,根据语法规则,检查输入的sql语句是否满足sql语法.不满足语法就直接返回错误信息.查询结束.

##### 优化器

经过分析器之后,MySQL便知道了需要做什么了.但在执行之前还要经过优化器的处理:

* 优化器主要是决定使用哪个索引;

* 或者当一个语句多表关联的时候,优化器来决定各个表的连接顺序.

经过优化器之后语句的执行方案就确定下来了,之后就进入执行器阶段.

##### 执行器

MySQL通过`分析器`知道了要做什么,通过`优化器`确定了怎么做,于是就进入`执行器`阶段,开始执行sql.

开始执行时会判断一下用户对这个表T有没有权限,没有就返回权限错误:

```sql
mysql> select * from T where ID='1';

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限,就打开表开始执行.打开表时执行器会根据表的引擎定义,去调用引擎接口.

比如这个上面的sql例子中,假如id列**没有索引**,那么执行器的流程是这样的:

1. 调用InnoDB引擎接口`获取表的第一行`,判断id列是不是1,不是就跳过,是就是将这行结果放到记录集中.
2. 调用引擎的''下一行''接口,继续判断,直到最后一行.
3. 执行器将上述遍历过程中符合条件的行组成的记录集作为结果集返回给客户端

对于**有索引的列**的查询逻辑也差不多:第一次是调用`取满足条件的第一行`这个接口,之后循环取`满足条件的下一行`接口.

#### 2.小结

1. MySQL的框架有几个组件, 各是什么作用?
2. Server层和存储引擎层各是什么作用?
3. you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?
4. 对于表的操作权限验证在哪里进行?
5. 执行器的执行查询语句的流程是什么样的?