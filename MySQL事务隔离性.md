### MySQL事务隔离性

#### 事务的特性：ACID

Atomicity、Consistency、Isolation、Durability：原子性、一致性、隔离性、持久性

#### 隔离级别：

* 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到

* 读已提交：一个事务提交之后，它做的变更才会被其他事务看到

* 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的

* 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

```sql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

|         事务A         |          事务B          |
| :-------------------: | :---------------------: |
| 启动事务，查询得到值1 |        启动事物         |
|                       | 查询得到值1，将1修改为2 |
|      查询得到V1       |                         |
|                       |        提交事务B        |
|     查询得到值V2      |                         |
|       提交事务        |                         |
|     查询得到值V3      |                         |

* 读未提交：V1的值是2，事务B没有提交，但是A已经可以看到了，V2、V3都是2
* 读已提交：V1是1，V2、V3是2。事务B在提交之后事务A才能看到。
* 可重复读：V1、V2都是1，V3是2。事务在执行期间看到的数据需要前后一致
* 串行化：在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2

**在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。**

* 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
* 在“读提交”隔离级别下，这个视图是在**每个**SQL语句开始执行的时候创建的。
* “读未提交”隔离级别下，直接返回记录上的最新值，没有视图概念。
* “串行化”隔离级别下，直接用加锁的方式来避免并行访问

在可重复读这个隔离级别时：

MVCC可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此开销更低。MVCC的实现大都都实现了非阻塞的读操作，写操作也只锁定必要的行。InnoDB的MVCC实现，是通过保存数据在某个时间点的快照来实现的。**一个事务，不管其执行多长时间，其内部看到的数据是一致的**。也就是事务在执行的过程中不会相互影响。下面我们简述一下MVCC在InnoDB中的实现。

　　InnoDB的MVCC，**通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的创建时间，一个保存行的过期时间（删除时间），当然，这里的时间并不是时间戳，而是系统版本号，每开始一个新的事务，系统版本号就会递增**。在RR隔离级别下，MVCC的操作如下：

1. select操作
   - **InnoDB只查找版本早于（包含等于）当前事务版本的数据行**。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。
   - **行的删除版本要么未定义，要么大于当前事务版本号**。可以确保事务读取的行，在事务开始之前未删除。
2. insert操作。将新插入的行保存当前版本号为行版本号。
3. delete操作。将删除的行保存当前版本号为删除标识。
4. update操作。变为insert和delete操作的组合，insert的行保存当前版本号为行版本号，delete则保存当前版本号到原来的行作为删除标识。

　　由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是**将删除版本号小于当前系统版本的行删除**，这个过程叫做purge。

例子具体看这个 : [mysql的MVCC（多版本并发控制） - myseries - 博客园 (cnblogs.com)](https://www.cnblogs.com/myseries/p/10930910.html)

### 小结

1. 事务的概念是什么?
2. mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?
3. 读已提交, 可重复读是怎么通过视图构建实现的?
4. 可重复读的使用场景举例? 对账的时候应该很有用?
5. 事务隔离是怎么通过read-view(读视图)实现的?
6. 并发版本控制(MCVV)的概念是什么, 是怎么实现的?
7. 使用长事务的弊病? 为什么使用常事务可能拖垮整个库?
8. 事务的启动方式有哪几种?
9. commit work and chain的语法是做什么用的?
10. 怎么查询各个表中的长事务?
11. 如何避免长事务的出现?