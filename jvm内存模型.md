* Java内存（运行时数据区）分为5个区域：
  * 方法区、堆；线程共享
  * 程序计数器、本地方法栈、虚拟机栈；线程私有
* 程序计数器 PC：记录虚拟机字节码的地址。本地方法（native）PC为空,唯一一块无 OOM 的内存区域
* Java栈（虚拟机栈）：程序运行时为每个方法在虚拟机栈中创建一个栈帧
  * 栈帧中包含
    * 局部变量表：方法定义的局部变量以及方法的参数，这里面的参数不能直接使用，需要通过指令加载到操作数栈中作为操作数来使用
    * 操作数栈：方法处理的数据，入栈和出栈的方式存储
    * 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，用来支持方法的动态链接
    * 方法返回地址：方法返回：遇到返回字节码；遇到未处理的异常



Java对象在内存中由三个部分组成:

* 对象头：
  * Mark Word   标记位：哈希码、分代年龄、锁状态标志
  * Class Pointer 指向对象对应的类元数据内存地址
  * Length（数组对象特有） 数组的长度
* 实例数据 包含对象的所有成员变量
  * boolean和byte :1字节
  * short和char ：2字节
  * int和float ：4字节
  * long和double 8字节
  * reference（引用） ：8字节
* 对齐填充 对象大小是8字节的整数倍大小

内存模型：

* 堆：分为两大块，一个是Old区，一个是Young区。Young区分为两大块，一个是Survivor区（S0 和S1），一块是Eden区。Eden : S0 : S1 =  8 : 1 : 1 S0 和 S1 一样大，也可以叫From和To区

  * 对象创建的区域
    * 一般情况，新创建的对象会被分配到Eden区，特殊的大的对象会被直接放到Old区。
    * Eden区满了（空间到达临界值）就需要对Eden区进行内存回收，即垃圾收集( GC )这样的GC称为Minor GC，即清理Young区的过程，清理之后存活的对象就需要复制到Survivor区，然后再清空Eden中的对象。

  * Survivor区
    * 同一时刻，S0和S1只有一个区有数据，另一个区是空的
    * Young区进行垃圾收集时会把Eden和From区需要保留的对象复制到Survivor的To区，并且对象年龄+1(Eden区到survivor区时对象初始年龄为1)，然后清空Eden和From,接着From和To交换角色等待下一此收集，也就是说Minor GC一定会保证To区是空的。当年龄到一定程度，默认是15，就会被移动到老年代。
  * 堆容易出现OutOfMemoryError错误：
    * OutOfMemoryError: GC Overhead Limit Exceeded ：JVM花费太多时间执行回收垃圾并且只能回收很少的空间
    * java.lang.OutOfMemoryError: Java heap space ：创建新对象时堆内存不足够创建时

  

  * Odl区的回收
    * 一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象，在Old区的GC我们成为Major GC,每次GC之后年龄也会+1，超过某个阈值就会被回收。

  我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有 一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在 Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯 了。于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的,我在这里也认识了很多人。在年老代里,我生活了20年(每次 GC加一岁),然后被回收。