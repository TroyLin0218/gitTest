### 基本问题

- 介绍下 Java 内存区域（运行时数据区）
- Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
- 对象的访问定位的两种方式（句柄和直接指针两种方式）

### 内存模型：

* Java内存（运行时数据区）分为5个区域：
  * 方法区、堆；**`线程共享`**
  * 程序计数器、本地方法栈、虚拟机栈；**`线程私有`**

#### 堆：

Java虚拟机管理的最大的一块区域，线程共享，主要存放对象实例和数组。堆分为两大块，一个是Old区，一个是Young区。Young区分为两大块，一个是Survivor区（S0 和S1），一块是Eden区。Eden : S0 : S1 =  8 : 1 : 1 S0 和 S1 一样大，也可以叫From和To区。

* 对象创建的区域
  * 一般情况，新创建的对象会被分配到Eden区，特殊的大的对象会被直接放到Old区。
  * Eden区满了（空间到达临界值）就需要对Eden区进行内存回收，即垃圾收集( GC )这样的GC称为Minor GC，即清理Young区的过程，清理之后存活的对象就需要复制到Survivor区，然后再清空Eden中的对象。**`新生代采用的复制算法来回收空间`**

* Survivor区
  * 同一时刻，S0和S1只有一个区有数据，另一个区是空的
  * Young区进行垃圾收集时会把Eden和From区需要保留的对象复制到Survivor的To区，并且对象年龄+1(Eden区到survivor区时对象初始年龄为1)，然后清空Eden和From,接着From和To交换角色等待下一次收集，也就是说Minor GC一定会保证To区是空的。当年龄到一定程度，默认是15，就会被移动到老年代。
* 堆容易出现OutOfMemoryError错误：
  * `OutOfMemoryError: GC Overhead Limit Exceeded` ：JVM花费太多时间执行回收垃圾并且只能回收很少的空间
  * `java.lang.OutOfMemoryError: Java heap space` ：创建新对象时堆内存不足够创建时

* Odl区的回收
  * 一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象，在Old区的GC我们成为Major GC,每次GC之后年龄也会+1，超过某个阈值就会被回收。**`老年代采用的标记整理算法来回收空间`**

``` java
/*
我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有 一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在 Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯 了。于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的,我在这里也认识了很多人。在年老代里,我生活了20年(每次 GC加一岁),然后被回收。
*/
```

**`JDK8的时候方法区被(HotSpot)彻底移除了，取而代之的是元空间(Metaspace)，元空间使用的是直接空间`**

#### 方法区

同堆一样，是线程共享内存区域，用来存储jvm加载的**`类信息、常量、静态常量、即时编译器编译后的代码`**等数据。方法区又称为Non-heap(非堆)，同时方法区也被称为永久代，可以把方法区理解为**`HotSpot对JVM规范中的永久代的一种实现`**。

##### 问题：为什么要用元空间来替换永久代呢？

1. 永久代用的是JVM本身设置的空间大小，元空间用的是物理内存，不受JVM限制，可以有效减少空间溢出的几率。元空间溢出时会出现：`java.lang.OutOfMemoryError: Metaspace`错误，默认不受最大限制，可以通过参数设置上限

2. 元空间主要存放类的元数据，使用直接内存就剋加载更多的类
3. JDK8，合并HotSpot和JRockit代码时，JRockit没有永久代的东西

##### 运行时常量池

运行时常量池也是方法区的一部分，Class文件中除了有版本、字段、方法、接口等描述信息之外，还有常量池表(用于存放编译时期生成的各种字面量和符号引用)，当常量池无法申请到内存时也会抛出`OutOfMemoryError`

1. JDK7之前运行时常量池逻辑包含**`字符串常量池`**,存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代
2. JDK7 字符串常量池被从方法区拿到了堆中,运行时常量池剩下的东西还在方法区, 也就是Hotspot中的永久代

3. JDK8的HotSpot移除了永久代，用元空间取而代之，这时候字符串常量池还在堆中，运行时常量池在方法区，只不过方法区的实现变为了元空间。

#### Java栈（虚拟机栈）

虚拟机栈也是此案成私有的，他的生命周期和线程相同，描述Java方法执行的内存模型，每次方法调用的数据都是通过栈来传递的。

程序运行时JVM会为每个方法在虚拟机栈中创建一个栈帧,方法调用完之后会弹出当前对象的栈帧

* 栈帧中包含
  * 局部变量表：方法定义的局部变量以及方法的参数，这里面的参数不能直接使用，需要通过指令加载到操作数栈中作为操作数来使用
  * 操作数栈：方法处理的数据，入栈和出栈的方式存储
  * 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，用来支持方法的动态链接
  * 方法返回地址：方法返回的两种情况：1. 遇到返回字节码(return语句)；2.遇到未处理的异常

* 虚拟栈会出现两种错误：
  * `StackOverFlowError` :若Java虚拟机的内存大小不允许动态扩展，那么当线程请求的栈深度超过当前虚拟机栈的最大深度时就会抛出该错误。
  * `OutOfmMemoryError`：若虚拟机栈中没有空闲空间并且GC也无法回收足够空间时就会抛出此错误。

#### 程序计数器 PC：

记录虚拟机字节码的地址。本地方法（native）PC为空,唯一一块无 OOM 的内存区域

1. 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码流程控制
2. 多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来时能够知道上次执行到什么地方了。

#### 本地方法栈

和虚拟机栈发挥的作用很像，区别是：**`虚拟机栈是为虚拟机执行Java方法(字节码)服务，而本地方法栈祖师为虚拟机执行Native方法服务`**。HotSpot虚拟机中和Java虚拟机栈合二为一。

本地方法被执行时也会在本地方法栈中创建栈帧，用于存放该方法的**`局部变量表、操作数栈、动态链接、出口信息`**

同样也会出现和虚拟机栈类似的两种错误：

`StackOverFlowError`和`OutOfMemoryError`

#### Java对象

##### 对象创建

* 类加载检查

  虚拟机遇到new指令时，首先区检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经加载过、解析过和初始化过。如果还没有，则执行类的加载过程。

* 分配内存

  类加载和检查之后，虚拟机就开始为新生对象分配内存。所需空间大小在类加载完成之后便确定，内存分配就是把一块内存空间从Java堆中划分出来。分配方式有：指针碰撞和空闲列表两种，使用哪种方式又取决于Java堆是否规整，而Java堆是否规整又取决于采用的垃圾收集算法是否带有压缩整理功能。

  * 指针碰撞：用过的内存全部整合到一边，没用过的内存放到另一边，中间一个分界指针，只需要想着没用过的内存方向将该指针移动对象所需大小的位置即可。

  * 空闲列表：虚拟机维护一个空闲列表，标记那些内存块时可用的，分配的时候找一块足够大的空间划分给对象，然后更新列表即可。

  内存分配并发问题：实际情况下，创建对象是很繁琐的事，需要保证线程安全

  * CAS+失败重试：CAS是乐观锁的一种实现方式。乐观锁:每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**`在虚拟机采用CAS配上失败重试的方式保证更新操作的原子性`**。
  * TLAB：为每一个线程预先在Eden中分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB内存用尽时在采用CAS进行内存分配。

* 初始化零值

  内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值(不含对象头)，可以保证对象的实例字段在不赋初始值就可以直接使用。

* 设置对象头

  初始化零值之后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

* 执行init方法：

  从虚拟机角度来看，对象创建已经完事了，但是Java程序来看，对象创建才刚开始，`<init>`还没执行，所有字段都还为零，执行`<init>`方法按照程序的意愿初始化，这才算创建一个对象。

##### 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

* 对象头：
  * Mark Word   标记位：哈希码、分代年龄、锁状态标志
  * Class Pointer 指向对象对应的类元数据内存地址
  * Length（数组对象特有） 数组的长度
* 实例数据 包含对象的所有成员变量
  * boolean和byte :1字节
  * short和char ：2字节
  * int和float ：4字节
  * long和double 8字节
  * reference（引用） ：8字节
* 对齐填充 对象大小需要是8字节的整数倍大小

##### 对象的访问定位

创建对象就是为了使用，Java程序通过栈上的reference数据来操作堆上的具体对象，对象的访问由虚拟机实现来确定：**`使用句柄`**和**`直接指针`**

句柄：

* Java堆将会划分一块内存来作为句柄池，reference中存放对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息
* 好处：对象移动时仅需修改句柄中的实例数据，reference本身不需要修改

直接指针：

* Java堆的对象布局中就必须考虑如何防止类型数据的相关信息，而reference中存储的直接就是对象地址
* 好处：速度快，节省了一次指针定位的时间开销